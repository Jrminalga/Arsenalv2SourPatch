-- Load UI Library
local Luxtl = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Luxware-UI-Library/main/Source.lua"))()
local Luxt = Luxtl.CreateWindow("Sour Patch", 6105620301)

-- Tabs
local mainTab = Luxt:Tab("Visuals", 6087485864)
local automationTab = Luxt:Tab("Automation")
local movementTab = Luxt:Tab("Movement")
local Weaponstab = Luxt:Tab("Weapons")
local creditsTab = Luxt:Tab("Credits")

-- Credits
local cf = creditsTab:Section("Main Credits")
cf:Credit("Jrminalga")
local cf1 = creditsTab:Section("UI Credits")
cf1:Credit("xHeptc: UI Library")
local cf2 = creditsTab:Section("Helping Credits")
cf2:Credit("Salad: Helping")

-----------------------------------------------------
-- ESP System (Visuals Tab)
-----------------------------------------------------
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- ESP Settings
local ESPSettings = {
    Enabled = false,
    BoxESP = true,
    SkeletonESP = false,
    Tracers = false,
    UseVisible = false,
    TeamCheck = false,
    ShowNames = true,
    ShowDistance = true,
    BoxColor = Color3.fromRGB(255, 255, 255),
    SkeletonColor = Color3.fromRGB(255, 255, 255),
    TracerColor = Color3.fromRGB(255, 255, 255),
    VisibleColor = Color3.fromRGB(0, 255, 0),
    BoxScale = 0.2,

    -- Visibility parts
    CheckHead = true,
    CheckTorso = true,
    CheckArms = true,
    CheckLegs = true,
    CheckHRP = true
}

local espObjects = {}

-- Utility: Parse RGB from string
local function parseRGB(input, default)
    local r, g, b = input:match("(%d+),(%d+),(%d+)")
    if r and g and b then
        r, g, b = tonumber(r), tonumber(g), tonumber(b)
        r = math.clamp(r, 0, 255)
        g = math.clamp(g, 0, 255)
        b = math.clamp(b, 0, 255)
        return Color3.fromRGB(r, g, b)
    end
    return default
end

-- Smart visibility check (raycast)
local function isVisibleSmart(character)
    if not ESPSettings.UseVisible then return true end

    local partsToCheck = {}

    if ESPSettings.CheckHead and character:FindFirstChild("Head") then
        table.insert(partsToCheck, character.Head)
    end
    if ESPSettings.CheckTorso and (character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")) then
        table.insert(partsToCheck, character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso"))
    end
    if ESPSettings.CheckArms then
        local leftArm = character:FindFirstChild("Left Arm") or character:FindFirstChild("LeftUpperArm")
        local rightArm = character:FindFirstChild("Right Arm") or character:FindFirstChild("RightUpperArm")
        if leftArm then table.insert(partsToCheck, leftArm) end
        if rightArm then table.insert(partsToCheck, rightArm) end
    end
    if ESPSettings.CheckLegs then
        local leftLeg = character:FindFirstChild("Left Leg") or character:FindFirstChild("LeftUpperLeg")
        local rightLeg = character:FindFirstChild("Right Leg") or character:FindFirstChild("RightUpperLeg")
        if leftLeg then table.insert(partsToCheck, leftLeg) end
        if rightLeg then table.insert(partsToCheck, rightLeg) end
    end
    if ESPSettings.CheckHRP and character:FindFirstChild("HumanoidRootPart") then
        table.insert(partsToCheck, character.HumanoidRootPart)
    end

    for _, part in ipairs(partsToCheck) do
        local ray = Ray.new(Camera.CFrame.Position, (part.Position - Camera.CFrame.Position).Unit * 5000)
        local hitPart = workspace:FindPartOnRayWithIgnoreList(ray, {LocalPlayer.Character}, false, true)
        if not hitPart or hitPart:IsDescendantOf(character) then
            return true
        end
    end

    return false
end

-- Skeleton lines creation
local function createSkeleton()
    local lines = {}
    for i = 1, 6 do
        local line = Drawing.new("Line")
        line.Thickness = 2
        line.Visible = false
        table.insert(lines, line)
    end
    return lines
end

-- Create ESP for a player
local function createESP(player)
    if espObjects[player] then return end
    espObjects[player] = {
        Box = Drawing.new("Square"),
        Skeleton = createSkeleton(),
        Tracer = Drawing.new("Line"),
        Name = Drawing.new("Text"),
        Distance = Drawing.new("Text")
    }

    -- Box setup
    espObjects[player].Box.Thickness = 2
    espObjects[player].Box.Filled = false
    espObjects[player].Box.Visible = false

    -- Tracer setup
    espObjects[player].Tracer.Thickness = 1.5
    espObjects[player].Tracer.Visible = false

    -- Name setup
    espObjects[player].Name.Center = true
    espObjects[player].Name.Outline = true
    espObjects[player].Name.Size = 16
    espObjects[player].Name.Visible = false

    -- Distance setup
    espObjects[player].Distance.Center = true
    espObjects[player].Distance.Outline = true
    espObjects[player].Distance.Size = 14
    espObjects[player].Distance.Visible = false

    -- Cache character parts
    espObjects[player].Parts = {
        Head = player.Character:FindFirstChild("Head"),
        UpperTorso = player.Character:FindFirstChild("UpperTorso") or player.Character:FindFirstChild("Torso"),
        HRP = player.Character:FindFirstChild("HumanoidRootPart"),
        LeftArm = player.Character:FindFirstChild("Left Arm") or player.Character:FindFirstChild("LeftUpperArm"),
        RightArm = player.Character:FindFirstChild("Right Arm") or player.Character:FindFirstChild("RightUpperArm"),
        LeftLeg = player.Character:FindFirstChild("Left Leg") or player.Character:FindFirstChild("LeftUpperLeg"),
        RightLeg = player.Character:FindFirstChild("Right Leg") or player.Character:FindFirstChild("RightUpperLeg")
    }
end

-- Remove ESP
local function removeESP(player)
    if not espObjects[player] then return end
    if espObjects[player].Box then espObjects[player].Box:Remove() end
    if espObjects[player].Tracer then espObjects[player].Tracer:Remove() end
    for _, l in pairs(espObjects[player].Skeleton) do l:Remove() end
    if espObjects[player].Name then espObjects[player].Name:Remove() end
    if espObjects[player].Distance then espObjects[player].Distance:Remove() end
    espObjects[player] = nil
end

Players.PlayerRemoving:Connect(removeESP)

-- Visibility throttling
local lastVisibilityCheck = 0
local visibilityUpdateRate = 0.2

-- Main ESP loop
RunService.RenderStepped:Connect(function(delta)
    if not ESPSettings.Enabled then
        for _, v in pairs(espObjects) do
            v.Box.Visible = false
            v.Tracer.Visible = false
            for _, l in pairs(v.Skeleton) do l.Visible = false end
            v.Name.Visible = false
            v.Distance.Visible = false
        end
        return
    end

    -- Update visibility cache
    lastVisibilityCheck = lastVisibilityCheck + delta
    if lastVisibilityCheck >= visibilityUpdateRate then
        lastVisibilityCheck = 0
        for _, player in pairs(Players:GetPlayers()) do
            if espObjects[player] and player.Character then
                espObjects[player].Visible = (not ESPSettings.UseVisible) or isVisibleSmart(player.Character)
            end
        end
    end

    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer or not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then continue end
        if not espObjects[player] then createESP(player) end

        local hrp = espObjects[player].Parts.HRP
        local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
        local distance = (Camera.CFrame.Position - hrp.Position).Magnitude
        if distance > 500 then
            espObjects[player].Box.Visible = false
            espObjects[player].Tracer.Visible = false
            for _, l in pairs(espObjects[player].Skeleton) do l.Visible = false end
            espObjects[player].Name.Visible = false
            espObjects[player].Distance.Visible = false
            continue
        end

        -- Team check
        if ESPSettings.TeamCheck and LocalPlayer.Team and player.Team == LocalPlayer.Team then
            espObjects[player].Box.Visible = false
            espObjects[player].Tracer.Visible = false
            for _, l in pairs(espObjects[player].Skeleton) do l.Visible = false end
            espObjects[player].Name.Visible = false
            espObjects[player].Distance.Visible = false
            continue
        end

        -- Colors
        local colorBox = ESPSettings.BoxColor
        local colorSkeleton = ESPSettings.SkeletonColor
        local colorTracer = ESPSettings.TracerColor
        if ESPSettings.UseVisible and espObjects[player].Visible then
            colorBox = ESPSettings.VisibleColor
            colorSkeleton = ESPSettings.VisibleColor
            colorTracer = ESPSettings.VisibleColor
        end

        -- Box
        if ESPSettings.BoxESP then
            local scale = ESPSettings.BoxScale / distance * 200
            local width, height = 30 * scale, 60 * scale
            local box = espObjects[player].Box
            box.Position = Vector2.new(pos.X - width / 2, pos.Y - height / 2)
            box.Size = Vector2.new(width, height)
            box.Color = colorBox
            box.Visible = onScreen
        else
            espObjects[player].Box.Visible = false
        end

        -- Skeleton
        if ESPSettings.SkeletonESP then
            local parts = espObjects[player].Parts
            local skeleton = espObjects[player].Skeleton
            local function connect(i, partA, partB)
                if partA and partB then
                    local a, visA = Camera:WorldToViewportPoint(partA.Position)
                    local b, visB = Camera:WorldToViewportPoint(partB.Position)
                    if visA and visB then
                        skeleton[i].From = Vector2.new(a.X, a.Y)
                        skeleton[i].To = Vector2.new(b.X, b.Y)
                        skeleton[i].Color = colorSkeleton
                        skeleton[i].Visible = true
                    else
                        skeleton[i].Visible = false
                    end
                else
                    skeleton[i].Visible = false
                end
            end
            connect(1, parts.Head, parts.UpperTorso)
            connect(2, parts.UpperTorso, parts.HRP)
            connect(3, parts.UpperTorso, parts.LeftArm)
            connect(4, parts.UpperTorso, parts.RightArm)
            connect(5, parts.HRP, parts.LeftLeg)
            connect(6, parts.HRP, parts.RightLeg)
        else
            for _, l in pairs(espObjects[player].Skeleton) do l.Visible = false end
        end

        -- Tracer
        if ESPSettings.Tracers then
            local tracer = espObjects[player].Tracer
            local screenBottom = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
            tracer.From = screenBottom
            tracer.To = Vector2.new(pos.X, pos.Y)
            tracer.Color = colorTracer
            tracer.Visible = onScreen
        else
            espObjects[player].Tracer.Visible = false
        end

        -- Name
        if ESPSettings.ShowNames then
            espObjects[player].Name.Position = Vector2.new(pos.X, pos.Y - 50)
            espObjects[player].Name.Text = player.Name
            espObjects[player].Name.Color = colorBox
            espObjects[player].Name.Visible = onScreen
        else
            espObjects[player].Name.Visible = false
        end

        -- Distance
        if ESPSettings.ShowDistance then
            espObjects[player].Distance.Position = Vector2.new(pos.X, pos.Y - 35)
            espObjects[player].Distance.Text = math.floor(distance).." studs"
            espObjects[player].Distance.Color = colorBox
            espObjects[player].Distance.Visible = onScreen
        else
            espObjects[player].Distance.Visible = false
        end
    end
end)

-----------------------------------------------------
-- GUI: ESP Settings
-----------------------------------------------------
local espOptions = mainTab:Section("ESP Options")
espOptions:Toggle("Enable ESP", function(v) ESPSettings.Enabled = v end)
espOptions:Toggle("Box ESP", function(v) ESPSettings.BoxESP = v end)
espOptions:Toggle("Skeleton ESP", function(v) ESPSettings.SkeletonESP = v end)
espOptions:Toggle("Is Visible", function(v) ESPSettings.UseVisible = v end)
espOptions:Toggle("Team Check", function(v) ESPSettings.TeamCheck = v end)
espOptions:Toggle("Tracers", function(v) ESPSettings.Tracers = v end)
espOptions:Toggle("Show Names", function(v) ESPSettings.ShowNames = v end)
espOptions:Toggle("Show Distance", function(v) ESPSettings.ShowDistance = v end)

-- Visibility part toggles
local visSec = mainTab:Section("Visibility Part Toggles")
visSec:Toggle("Check Head", function(v) ESPSettings.CheckHead = v end)
visSec:Toggle("Check Torso", function(v) ESPSettings.CheckTorso = v end)
visSec:Toggle("Check Arms", function(v) ESPSettings.CheckArms = v end)
visSec:Toggle("Check Legs", function(v) ESPSettings.CheckLegs = v end)
visSec:Toggle("Check HRP", function(v) ESPSettings.CheckHRP = v end)

-- Color settings
local colorSec = mainTab:Section("ESP Colors")
colorSec:TextBox("Box ESP Color (R,G,B)", "255,255,255", function(input) ESPSettings.BoxColor = parseRGB(input, ESPSettings.BoxColor) end)
colorSec:TextBox("Skeleton ESP Color (R,G,B)", "255,255,255", function(input) ESPSettings.SkeletonColor = parseRGB(input, ESPSettings.SkeletonColor) end)
colorSec:TextBox("Tracers Color (R,G,B)", "255,255,255", function(input) ESPSettings.TracerColor = parseRGB(input, ESPSettings.TracerColor) end)
colorSec:TextBox("Visible Color (R,G,B)", "0,255,0", function(input) ESPSettings.VisibleColor = parseRGB(input, ESPSettings.VisibleColor) end)

-----------------------------------------------------
-- Silent Aim System (Automation Tab)
-----------------------------------------------------
local silentAimSection = automationTab:Section("Silent Aim Settings")
local silentAimSettings = {
    Enabled = false,
    ShowFOV = true,
    FOVSize = 60,
    FOVColor = Color3.fromRGB(255, 255, 255),
    FOVTransparency = 0.5,
    FOVFilled = false,
    FOVThickness = 1,
    FOVEnemyInside = false,
    FOVEnemyInsideColor = Color3.fromRGB(255, 0, 0),
    TeamCheck = false
}

local silentAimConnections = {}
local fovCircle = nil

local function createFOV()
    if not Drawing or not Drawing.new then return end
    fovCircle = Drawing.new("Circle")
    fovCircle.Visible = silentAimSettings.Enabled and silentAimSettings.ShowFOV
    fovCircle.Color = silentAimSettings.FOVColor
    fovCircle.Transparency = silentAimSettings.FOVTransparency
    fovCircle.Filled = silentAimSettings.FOVFilled
    fovCircle.Thickness = silentAimSettings.FOVThickness
    fovCircle.Radius = silentAimSettings.FOVSize
    fovCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
end

local function updateFOV()
    if not fovCircle then return end
    fovCircle.Visible = silentAimSettings.Enabled and silentAimSettings.ShowFOV
    fovCircle.Color = silentAimSettings.FOVColor
    fovCircle.Transparency = silentAimSettings.FOVTransparency
    fovCircle.Filled = silentAimSettings.FOVFilled
    fovCircle.Thickness = silentAimSettings.FOVThickness
    fovCircle.Radius = silentAimSettings.FOVSize
end

local function isInFOV(part)
    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
    if not onScreen then return false end
    local mousePos = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    return (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude <= fovCircle.Radius
end

local function modifyParts()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            for _, partName in ipairs({"RightUpperLeg","LeftUpperLeg","HeadHB","HumanoidRootPart"}) do
                local part = player.Character:FindFirstChild(partName)
                if part then
                    part.Transparency = 10
                    part.CanCollide = false
                    part.Size = Vector3.new(13, 13, 13)
                end
            end
        end
    end
end

silentAimSection:Toggle("Enable Silent Aim", function(value)
    silentAimSettings.Enabled = value
    for _, con in pairs(silentAimConnections) do con:Disconnect() end
    silentAimConnections = {}

    if value then
        if not fovCircle then createFOV() else updateFOV() end
        modifyParts()

        table.insert(silentAimConnections, Players.PlayerAdded:Connect(function(player)
            if not silentAimSettings.Enabled then return end
            table.insert(silentAimConnections, player.CharacterAdded:Connect(function(char)
                if not silentAimSettings.Enabled then return end
                wait(1)
                modifyParts()
            end))
        end))

        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                table.insert(silentAimConnections, player.CharacterAdded:Connect(function(char)
                    if not silentAimSettings.Enabled then return end
                    wait(1)
                    modifyParts()
                end))
            end
        end

        table.insert(silentAimConnections, game:GetService("RunService").Heartbeat:Connect(function()
            if silentAimSettings.Enabled then modifyParts() end
        end))
    elseif fovCircle then
        fovCircle.Visible = false
    end
end)

silentAimSection:Toggle("Show FOV Circle", function(value) silentAimSettings.ShowFOV = value updateFOV() end)
silentAimSection:Slider("FOV Size", 5, 200, function(value) silentAimSettings.FOVSize = value updateFOV() end)
silentAimSection:Slider("FOV Transparency", 0, 1, function(value) silentAimSettings.FOVTransparency = math.clamp(math.floor(value*10)/10, 0, 1) updateFOV() end)
silentAimSection:Toggle("FOV Filled", function(value) silentAimSettings.FOVFilled = value updateFOV() end)
silentAimSection:Slider("FOV Thickness", 1, 5, function(value) silentAimSettings.FOVThickness = value updateFOV() end)
silentAimSection:TextBox("FOV Color (R,G,B)", "255,255,255", function(input) silentAimSettings.FOVColor = parseRGB(input, silentAimSettings.FOVColor) updateFOV() end)
silentAimSection:Toggle("Team Check", function(value) silentAimSettings.TeamCheck = value end)
silentAimSection:Toggle("Change Color When Enemy In FOV", function(value) silentAimSettings.FOVEnemyInside = value end)
silentAimSection:TextBox("Enemy In FOV Color (R,G,B)", "255,0,0", function(input) silentAimSettings.FOVEnemyInsideColor = parseRGB(input, silentAimSettings.FOVEnemyInsideColor) end)

game:GetService("RunService").RenderStepped:Connect(function()
    if not silentAimSettings.Enabled or not fovCircle then return end
    local colorToUse = silentAimSettings.FOVColor
    if silentAimSettings.FOVEnemyInside then
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                if silentAimSettings.TeamCheck and LocalPlayer.Team == player.Team then continue end
                if isInFOV(player.Character.HumanoidRootPart) and isVisible(player.Character.HumanoidRootPart) then
                    colorToUse = silentAimSettings.FOVEnemyInsideColor
                    break
                end
            end
        end
    end
    fovCircle.Color = colorToUse
end)

-----------------------------------------------------
-- Aimbot Section (Automation Tab)
-----------------------------------------------------
local AimbotSection = automationTab:Section("Aimbot")

-- Services & variables
local UIS = game:GetService("UserInputService")
local Players = game:GetService("Players")
local camera = workspace.CurrentCamera
local localPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")

local aimTween = nil
local lastTarget = nil
local currentKeybind = Enum.UserInputType.MouseButton2
_G.AimAssistEnabled = false
_G.aim = false
_G.Smoothness = 0.15
_G.Prediction = 0.08
_G.TeamCheck = false
_G.FOVEnabled = false -- FOV off by default
local FOVCircleRadius = 150

-----------------------------------------------------
-- UI Elements
-----------------------------------------------------
AimbotSection:Toggle("Aim Assist", function(val)
    _G.AimAssistEnabled = val
end)

-- Team Check toggle
AimbotSection:Toggle("Team Check", function(val)
    _G.TeamCheck = val
end)

-- FOV toggle
AimbotSection:Toggle("FOV Circle Enabled", function(val)
    _G.FOVEnabled = val
end)

-- Helpful label
AimbotSection:Label("Smoothness (0.02-0.30, smaller = snappier).")
AimbotSection:Label(" Prediction (0.00-0.20 seconds, target lead).")

-- Smoothness TextBox
AimbotSection:TextBox("Smoothness (e.g., 0.15)", tostring(_G.Smoothness), function(text)
    local num = tonumber(text)
    if num and num > 0 then
        _G.Smoothness = math.clamp(num, 0.01, 1)
    else
        print("Invalid Smoothness input. Keeping previous value:", _G.Smoothness)
    end
end)

-- Prediction TextBox
AimbotSection:TextBox("Prediction (seconds, e.g., 0.08)", tostring(_G.Prediction), function(text)
    local num = tonumber(text)
    if num and num >= 0 then
        _G.Prediction = math.clamp(num, 0, 1)
    else
        print("Invalid Prediction input. Keeping previous value:", _G.Prediction)
    end
end)

-- FOV radius TextBox (user can change FOV size)
AimbotSection:TextBox("FOV Radius (pixels, e.g., 150)", tostring(FOVCircleRadius), function(text)
    local num = tonumber(text)
    if num and num > 0 then
        FOVCircleRadius = num
        if FOVCircle then
            FOVCircle.Radius = FOVCircleRadius
        end
    else
        print("Invalid FOV radius. Keeping previous value:", FOVCircleRadius)
    end
end)

-- Keybind
AimbotSection:KeyBind("Aim Keybind", Enum.UserInputType.MouseButton2, function(key)
    currentKeybind = key
end)

-----------------------------------------------------
-- FOV Circle
-----------------------------------------------------
local FOVCircle = Drawing.new("Circle")
FOVCircle.Thickness = 2
FOVCircle.Filled = false
FOVCircle.Radius = FOVCircleRadius
FOVCircle.Visible = _G.FOVEnabled
local FOVCenter = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)

RunService.RenderStepped:Connect(function()
    FOVCenter = Vector2.new(camera.ViewportSize.X/2, camera.ViewportSize.Y/2)
    FOVCircle.Position = FOVCenter
    FOVCircle.Radius = FOVCircleRadius
    FOVCircle.Visible = _G.FOVEnabled

    -- Color dynamically changes based on TeamCheck
    if _G.FOVEnabled then
        FOVCircle.Color = _G.TeamCheck and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
    end
end)

local function isInFOV(worldPos)
    if not _G.FOVEnabled then return true end -- all targets are valid if FOV off
    local screenPos, onScreen = camera:WorldToViewportPoint(worldPos)
    if not onScreen then return false end
    local dist = (Vector2.new(screenPos.X, screenPos.Y) - FOVCenter).Magnitude
    return dist <= FOVCircleRadius
end

-----------------------------------------------------
-- Smooth aiming using lerp
-----------------------------------------------------
local function smoothAim(targetPosition)
    if not camera or not camera.CFrame then return end
    local s = math.max(0.01, (_G.Smoothness or 0.15))
    local alpha = math.clamp(1 / (s * 30), 0.01, 1)
    camera.CFrame = camera.CFrame:Lerp(CFrame.new(camera.CFrame.Position, targetPosition), alpha)
end

-----------------------------------------------------
-- Targeting logic
-----------------------------------------------------
local function getClosest()
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then return nil end
    local closestDistance = math.huge
    local closestPlayer = nil
    local localRoot = localPlayer.Character.HumanoidRootPart

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= localPlayer then
            local character = player.Character
            if character and character:FindFirstChild("HumanoidRootPart") and character:FindFirstChild("Head") then
                -- Team check
                if not (_G.TeamCheck and player.Team == localPlayer.Team) then
                    local predictedPosition = character.Head.Position + (character.HumanoidRootPart.Velocity * (_G.Prediction or 0.08))
                    -- FOV check
                    if isInFOV(predictedPosition) then
                        local distance = (localRoot.Position - predictedPosition).Magnitude
                        if distance < closestDistance then
                            closestDistance = distance
                            closestPlayer = player
                        end
                    end
                end
            end
        end
    end

    return closestPlayer
end

local function aimLoop()
    while _G.aim and _G.AimAssistEnabled and task.wait() do
        local closest = getClosest()
        if closest and closest.Character and closest.Character:FindFirstChild("Head") then
            local predictedPosition = closest.Character.Head.Position + (closest.Character.HumanoidRootPart.Velocity * (_G.Prediction or 0.08))
            smoothAim(predictedPosition)
        end
    end
end

-----------------------------------------------------
-- Input handlers
-----------------------------------------------------
UIS.InputBegan:Connect(function(input, gp)
    if gp then return end
    local isPressed = false
    if typeof(currentKeybind) == "EnumItem" and currentKeybind.EnumType == Enum.UserInputType then
        isPressed = (input.UserInputType == currentKeybind)
    elseif typeof(currentKeybind) == "EnumItem" and currentKeybind.EnumType == Enum.KeyCode then
        isPressed = (input.KeyCode == currentKeybind)
    end
    if isPressed and _G.AimAssistEnabled then
        _G.aim = true
        task.spawn(aimLoop)
    end
end)

UIS.InputEnded:Connect(function(input, gp)
    if gp then return end
    local isReleased = false
    if typeof(currentKeybind) == "EnumItem" and currentKeybind.EnumType == Enum.UserInputType then
        isReleased = (input.UserInputType == currentKeybind)
    elseif typeof(currentKeybind) == "EnumItem" and currentKeybind.EnumType == Enum.KeyCode then
        isReleased = (input.KeyCode == currentKeybind)
    end
    if isReleased then
        _G.aim = false
    end
end)


-----------------------------------------------------
-- Teleport (Automation Tab)
-----------------------------------------------------

local tpSection = automationTab:Section("Teleport Cheats")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local tpEnabled = false -- Master toggle
local autoTPEnabled = false
local teamCheckEnabled = false
local tpKey = Enum.KeyCode.T
local tpSpeed = 1 -- Auto TP speed in seconds
local lastAutoTP = 0

-- Helper function to get random target
local function getRandomTarget()
    local targets = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            if teamCheckEnabled then
                if LocalPlayer.Team ~= player.Team then
                    table.insert(targets, player)
                end
            else
                table.insert(targets, player)
            end
        end
    end
    if #targets > 0 then
        return targets[math.random(1, #targets)]
    else
        return nil
    end
end

-- Function to teleport to a target
local function teleportToPlayer(player)
    if not tpEnabled then return end -- Master toggle check
    if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        LocalPlayer.Character.HumanoidRootPart.CFrame = player.Character.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
    end
end


--TP Toggle
tpSection:Toggle("Enable Teleport", function(isToggled)
    tpEnabled = isToggled
end)


-- Manual TP 
tpSection:KeyBind("Teleport to Random Player", tpKey, function()
    if not tpEnabled then return end -- Only works if master toggle is ON
    local target = getRandomTarget()
    if target then
        teleportToPlayer(target)
    end
end)


-- Team Check Toggle
tpSection:Toggle("Only Teleport to Enemies", function(isToggled)
    teamCheckEnabled = isToggled
end)


-- Auto TP Toggle
tpSection:Toggle("Auto TP", function(isToggled)
    autoTPEnabled = isToggled
end)


-- Auto TP Speed
tpSection:TextBox("Auto TP Speed (seconds)", "1", function(text)
    local speed = tonumber(text)
    if speed and speed > 0 then
        tpSpeed = speed
    else
        tpSpeed = 1
    end
end)


-- RunService loop for Auto TP
RunService.RenderStepped:Connect(function()
    if tpEnabled and autoTPEnabled then -- Auto TP only works if master toggle is ON
        if tick() - lastAutoTP >= tpSpeed then
            local target = getRandomTarget()
            if target then
                teleportToPlayer(target)
            end
            lastAutoTP = tick()
        end
    end
end)

-----------------------------------------------------
-- Fly System (Movement Tab)
-----------------------------------------------------
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local flySection = movementTab:Section("Fly Settings")

-- Fly State
local flyEnabled = false
local flyToggleAllowed = false
local flySpeed = 50
local flyKey = Enum.KeyCode.F -- default bind
local flyBodyVelocity = nil
local flyBodyGyro = nil

local function setFly(state)
    if flyBodyVelocity then pcall(function() flyBodyVelocity:Destroy() end) flyBodyVelocity = nil end
    if flyBodyGyro then pcall(function() flyBodyGyro:Destroy() end) flyBodyGyro = nil end

    flyEnabled = state

    if not state then return end
    local char = LocalPlayer.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    flyBodyVelocity = Instance.new("BodyVelocity")
    flyBodyVelocity.MaxForce = Vector3.new(1e5, 1e5, 1e5)
    flyBodyVelocity.Velocity = Vector3.new(0,0,0)
    flyBodyVelocity.Parent = hrp

    flyBodyGyro = Instance.new("BodyGyro")
    flyBodyGyro.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
    flyBodyGyro.CFrame = hrp.CFrame
    flyBodyGyro.Parent = hrp
end

-- GUI Controls
flySection:Toggle("Enable Fly (GUI)", function(value)
    flyToggleAllowed = value
    if not value then
        setFly(false)
    end
end)

flySection:Slider("Fly Speed", 10, 200, function(val)
    flySpeed = val
end)

flySection:KeyBind("Fly Toggle Key", flyKey, function()
    if flyToggleAllowed then
        setFly(not flyEnabled)
    end
end)

-- Fly Movement Handler
RunService.RenderStepped:Connect(function()
    if not flyEnabled or not flyBodyVelocity or not flyBodyGyro then return end

    local char = LocalPlayer.Character
    if not char then setFly(false) return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then setFly(false) return end

    -- Build movement vector
    local mv = Vector3.new(0,0,0)
    if UserInputService:IsKeyDown(Enum.KeyCode.W) then mv = mv + Vector3.new(0,0,-1) end
    if UserInputService:IsKeyDown(Enum.KeyCode.S) then mv = mv + Vector3.new(0,0,1) end
    if UserInputService:IsKeyDown(Enum.KeyCode.A) then mv = mv + Vector3.new(-1,0,0) end
    if UserInputService:IsKeyDown(Enum.KeyCode.D) then mv = mv + Vector3.new(1,0,0) end

    -- Vertical movement (world-relative, prevents drift)
    local vertical = 0
    if UserInputService:IsKeyDown(Enum.KeyCode.Space) then vertical = vertical + 1 end
    if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or UserInputService:IsKeyDown(Enum.KeyCode.RightShift) then
        vertical = vertical - 1
    end

    local vel = Vector3.new(0,0,0)
    if mv.Magnitude > 0 then
        local worldDir = Camera.CFrame:VectorToWorldSpace(mv)
        vel = vel + worldDir.Unit * flySpeed
    end
    if vertical ~= 0 then
        vel = vel + Vector3.new(0, vertical, 0) * flySpeed
    end

    flyBodyVelocity.Velocity = vel
    flyBodyGyro.CFrame = CFrame.new(hrp.Position, hrp.Position + Camera.CFrame.LookVector)
end)

-----------------------------------------------------
-- Jump Fly (Movement Tab)
-----------------------------------------------------
local jumpFlySection = movementTab:Section("Jump Fly Settings")

local jumpFlyEnabled = false
local jumpFlyPower = 50 -- vertical boost
local jumpFlyGravity = 150
local lastJumpTime = 0
local jumpCooldown = 0.2
local jumpFlyConnections = {}

-- Toggle Jump Fly
jumpFlySection:Toggle("Enable Jump Fly (Press F to toggle)", function(value)
    jumpFlyEnabled = value

    -- Cleanup old connections
    for _, con in pairs(jumpFlyConnections) do con:Disconnect() end
    jumpFlyConnections = {}

    if not value then
        if LocalPlayer.Character then
            local root = LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or LocalPlayer.Character:FindFirstChild("Torso")
            if root and root:FindFirstChild("JumpFlyGravity") then
                root.JumpFlyGravity:Destroy()
            end
        end
        return
    end

    -- Setup
    local function setupJumpFly()
        local char = LocalPlayer.Character
        if not char then return end
        local humanoid = char:FindFirstChild("Humanoid")
        local root = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso")
        if not humanoid or not root then return end

        -- BodyForce to control gravity
        local bf = Instance.new("BodyForce")
        bf.Name = "JumpFlyGravity"
        bf.Force = Vector3.new(0, -jumpFlyGravity * root:GetMass(), 0)
        bf.Parent = root

        local UIS = game:GetService("UserInputService")
        local RunService = game:GetService("RunService")

        -- Toggle with F key
        table.insert(jumpFlyConnections, UIS.InputBegan:Connect(function(input, gameProcessed)
            if not gameProcessed and input.KeyCode == Enum.KeyCode.F then
                jumpFlyEnabled = not jumpFlyEnabled
                Luxt:Notify({
                    Title = "Jump Fly",
                    Content = jumpFlyEnabled and "Enabled" or "Disabled",
                    Duration = 1
                })
            end
        end))

        -- Jump boost
        table.insert(jumpFlyConnections, UIS.JumpRequest:Connect(function()
            if jumpFlyEnabled and (tick() - lastJumpTime) > jumpCooldown then
                root.Velocity = Vector3.new(root.Velocity.X, jumpFlyPower, root.Velocity.Z)
                lastJumpTime = tick()
            end
        end))

        -- Horizontal movement mid-air
        table.insert(jumpFlyConnections, RunService.Heartbeat:Connect(function()
            if jumpFlyEnabled then
                if root:FindFirstChild("JumpFlyGravity") then
                    root.JumpFlyGravity.Force = Vector3.new(0, -jumpFlyGravity * root:GetMass(), 0)
                end

                local cam = workspace.CurrentCamera
                local dir = Vector3.new(0,0,0)
                if UIS:IsKeyDown(Enum.KeyCode.W) then dir = dir + cam.CFrame.LookVector end
                if UIS:IsKeyDown(Enum.KeyCode.S) then dir = dir - cam.CFrame.LookVector end
                if UIS:IsKeyDown(Enum.KeyCode.A) then dir = dir - cam.CFrame.RightVector end
                if UIS:IsKeyDown(Enum.KeyCode.D) then dir = dir + cam.CFrame.RightVector end
                dir = Vector3.new(dir.X, 0, dir.Z)
                if dir.Magnitude > 0 then
                    root.Velocity = Vector3.new(dir.Unit.X * 50, root.Velocity.Y, dir.Unit.Z * 50)
                end
            end
        end))
    end

    if LocalPlayer.Character then
        setupJumpFly()
    end

    table.insert(jumpFlyConnections, LocalPlayer.CharacterAdded:Connect(function()
        if jumpFlyEnabled then
            wait(0.5)
            setupJumpFly()
        end
    end))
end)

-----------------------------------------------------
-- Bhop System (Movement Tab)
-----------------------------------------------------

local humanoid = LocalPlayer.Character:WaitForChild("Humanoid")
local rootPart = LocalPlayer.Character:WaitForChild("HumanoidRootPart")
local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local BhopSettings = {
    Enabled = false,
    BaseSpeed = 16,
    Momentum = 16,
    MaxSpeed = 80,
    StrafeEnabled = false,
    LastMouseDelta = 0,
    MidAirIncrement = 0.2,
    StrafeMultiplier = 0.004,
    StrafeMaxBoost = 5
}

-- GUI
local bhopSection = movementTab:Section("Bhop Settings")

-- Enable Bhop toggle
bhopSection:Toggle("Enable Bhop", function(state)
    BhopSettings.Enabled = state
end)

-- Max Speed TextBox
bhopSection:TextBox("Max Bhop Speed", tostring(BhopSettings.MaxSpeed), function(input)
    local num = tonumber(input)
    if num then
        BhopSettings.MaxSpeed = math.clamp(num, BhopSettings.BaseSpeed, 500)
    end
end)

-- Mid-Air Increment TextBox
bhopSection:TextBox("Mid-Air Increment", tostring(BhopSettings.MidAirIncrement), function(input)
    local num = tonumber(input)
    if num then
        BhopSettings.MidAirIncrement = num
    end
end)

-- Strafe Multiplier TextBox
bhopSection:TextBox("Strafe Multiplier", tostring(BhopSettings.StrafeMultiplier), function(input)
    local num = tonumber(input)
    if num then
        BhopSettings.StrafeMultiplier = num
    end
end)

-- Enable Strafing Boost toggle
bhopSection:Toggle("Enable Strafing Boost", function(state)
    BhopSettings.StrafeEnabled = state
end)

-- Current Speed Label
local currentSpeedLabel = bhopSection:Label("Current Speed: " .. math.floor(BhopSettings.Momentum))

-- Track mouse movement for strafing
game:GetService("UserInputService").InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        BhopSettings.LastMouseDelta = input.Delta.X
    end
end)

-- Main Bhop logic safely
local function setupBhop(character)
    local humanoid = character:WaitForChild("Humanoid")
    local rootPart = character:WaitForChild("HumanoidRootPart")
    
    game:GetService("RunService").RenderStepped:Connect(function()
        if not humanoid then return end

        local onGround = humanoid.FloorMaterial ~= Enum.Material.Air
        local moving = humanoid.MoveDirection.Magnitude > 0
        local spaceDown = game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.Space)

        if BhopSettings.Enabled then
            if spaceDown and onGround then
                humanoid.Jump = true
            end

            if not onGround and moving then
                BhopSettings.Momentum = math.clamp(
                    BhopSettings.Momentum + BhopSettings.MidAirIncrement,
                    BhopSettings.BaseSpeed,
                    BhopSettings.MaxSpeed
                )

                if BhopSettings.StrafeEnabled then
                    local strafeBoost = math.clamp(
                        math.abs(BhopSettings.LastMouseDelta) * BhopSettings.StrafeMultiplier,
                        0,
                        BhopSettings.StrafeMaxBoost
                    )
                    BhopSettings.Momentum = math.clamp(
                        BhopSettings.Momentum + strafeBoost,
                        BhopSettings.BaseSpeed,
                        BhopSettings.MaxSpeed + BhopSettings.StrafeMaxBoost
                    )
                end
            elseif onGround and not spaceDown and BhopSettings.Momentum > BhopSettings.BaseSpeed then
                BhopSettings.Momentum = BhopSettings.BaseSpeed
            end

            humanoid.WalkSpeed = BhopSettings.Momentum
        end

        currentSpeedLabel.Text = "Current Speed: " .. math.floor(BhopSettings.Momentum)
    end)
end

-- Safe initialization
local player = game:GetService("Players").LocalPlayer
if player.Character then
    setupBhop(player.Character)
end
player.CharacterAdded:Connect(setupBhop)


-----------------------------------------------------
-- Speed Hack (Movement Tab)
-----------------------------------------------------
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

-- Create the Speed Section
local speedSection = movementTab:Section("Speed Settings")

-- Settings
local SpeedSettings = {
    Enabled = false,
    WalkSpeed = 16
}

-- Enable Speed Hack toggle
speedSection:Toggle("Enable Speed Hack", function(state)
    SpeedSettings.Enabled = state
    local char = player.Character
    if char and char:FindFirstChild("Humanoid") then
        local hum = char.Humanoid
        if not state then
            hum.WalkSpeed = 16 -- Reset to default
        end
    end
end)

-- Info label
speedSection:Label("Default walk speed is 16")

-- Walk Speed TextBox
speedSection:TextBox("Set Walk Speed", tostring(SpeedSettings.WalkSpeed), function(input)
    local num = tonumber(input)
    if num then
        SpeedSettings.WalkSpeed = math.clamp(num, 1, 500)
    end
end)

-- Current Speed Label
local speedCurrentLabel = speedSection:Label("Current Speed: " .. SpeedSettings.WalkSpeed)

-- Update loop
RunService.RenderStepped:Connect(function()
    local char = player.Character
    if char and char:FindFirstChild("Humanoid") then
        local hum = char.Humanoid
        if SpeedSettings.Enabled then
            hum.WalkSpeed = SpeedSettings.WalkSpeed
        end
        speedCurrentLabel.Text = "Current Speed: " .. math.floor(hum.WalkSpeed) -- Use .Text instead of :Set
    end
end)

-- Handle character respawn
player.CharacterAdded:Connect(function(char)
    local hum = char:WaitForChild("Humanoid")
    if not SpeedSettings.Enabled then
        hum.WalkSpeed = 16
    end
end)

-----------------------------------------------------
-- Fire Rate Modifier (Weapons Tab)
-----------------------------------------------------
local FireRateSection = Weaponstab:Section("Fire Rate Modifier")

FireRateSection:Label("⚠️ Don't set FireRate to 0 or lower — it may break shooting!")

local FireRateValue = 0.1 -- user-set value
local FireRateEnabled = false
local DefaultFireRates = {} -- stores original fire rates

-----------------------------------------------------
-- Store defaults first time
-----------------------------------------------------
local weaponsFolder = game:GetService("ReplicatedStorage"):FindFirstChild("Weapons")
if weaponsFolder then
    for _, weapon in ipairs(weaponsFolder:GetChildren()) do
        if weapon:IsA("Folder") then
            local fireRate = weapon:FindFirstChild("FireRate")
            if fireRate and fireRate:IsA("NumberValue") then
                DefaultFireRates[weapon.Name] = fireRate.Value
            end
        end
    end
end

-----------------------------------------------------
-- Fire Rate Input
-----------------------------------------------------
FireRateSection:TextBox("Enter Fire Rate", "e.g. 0.05", function(input)
    local num = tonumber(input)
    if num and num > 0 then
        FireRateValue = num
        print("Set FireRate value to:", FireRateValue)
        if FireRateEnabled then
            for _, weapon in ipairs(weaponsFolder:GetChildren()) do
                if weapon:IsA("Folder") then
                    local fireRate = weapon:FindFirstChild("FireRate")
                    if fireRate and fireRate:IsA("NumberValue") then
                        fireRate.Value = FireRateValue
                    end
                end
            end
            print("Applied new FireRate instantly since it's enabled.")
        end
    else
        warn("Invalid FireRate input! Must be a number greater than 0.")
    end
end)

-----------------------------------------------------
-- Toggle to enable/disable Fire Rate Hack
-----------------------------------------------------
FireRateSection:Toggle("Enable Fire Rate Hack", function(state)
    FireRateEnabled = state

    if state then
        print("🔥 Fire Rate Hack Enabled")
        for _, weapon in ipairs(weaponsFolder:GetChildren()) do
            if weapon:IsA("Folder") then
                local fireRate = weapon:FindFirstChild("FireRate")
                if fireRate and fireRate:IsA("NumberValue") then
                    fireRate.Value = FireRateValue
                end
            end
        end
    else
        print("🔁 Fire Rate Hack Disabled — restoring defaults")
        for _, weapon in ipairs(weaponsFolder:GetChildren()) do
            if weapon:IsA("Folder") then
                local fireRate = weapon:FindFirstChild("FireRate")
                if fireRate and fireRate:IsA("NumberValue") and DefaultFireRates[weapon.Name] then
                    fireRate.Value = DefaultFireRates[weapon.Name]
                end
            end
        end
    end
end)

-----------------------------------------------------
-- Force Full Automatic (Weapons Tab)
-----------------------------------------------------
local AutoSection = Weaponstab:Section("Force FullAuto")

local ForceAutoEnabled = false
local DefaultAutoValues = {} -- store original BoolValue for Auto

local weaponsFolder = game:GetService("ReplicatedStorage"):FindFirstChild("Weapons")

-- Backup original Auto values
if weaponsFolder then
    for _, weapon in ipairs(weaponsFolder:GetChildren()) do
        if weapon:IsA("Folder") then
            local autoValue = weapon:FindFirstChild("Auto")
            if autoValue and autoValue:IsA("BoolValue") then
                DefaultAutoValues[weapon.Name] = autoValue.Value
            end
        end
    end
else
    warn("Weapons folder not found in ReplicatedStorage!")
end

AutoSection:Label("💡 Forces all weapons to full auto mode.")

AutoSection:Toggle("Enable Force Full Auto", function(state)
    ForceAutoEnabled = state

    if not weaponsFolder then return end

    if state then
        print("🔁 Force Full Automatic Enabled")
        for _, weapon in ipairs(weaponsFolder:GetChildren()) do
            if weapon:IsA("Folder") then
                local autoValue = weapon:FindFirstChild("Auto")
                if autoValue and autoValue:IsA("BoolValue") then
                    autoValue.Value = true
                end
            end
        end
    else
        print("🔁 Force Full Automatic Disabled — restoring defaults")
        for _, weapon in ipairs(weaponsFolder:GetChildren()) do
            if weapon:IsA("Folder") then
                local autoValue = weapon:FindFirstChild("Auto")
                if autoValue and autoValue:IsA("BoolValue") and DefaultAutoValues[weapon.Name] ~= nil then
                    autoValue.Value = DefaultAutoValues[weapon.Name]
                end
            end
        end
    end
end)



-----------------------------------------------------
-- Infinite Ammo Section (Weapons Tab)
-----------------------------------------------------
local AmmoSection = Weaponstab:Section("Infinite Ammo")

local InfiniteAmmoEnabled = false
local DefaultAmmoValues = {} -- stores original ammo per weapon
local DefaultStoredAmmoValues = {} -- stores original stored ammo per weapon

local weaponsFolder = game:GetService("ReplicatedStorage"):FindFirstChild("Weapons")

-- Store defaults on startup
if weaponsFolder then
    for _, weapon in ipairs(weaponsFolder:GetChildren()) do
        if weapon:IsA("Folder") then
            local ammoValue = weapon:FindFirstChild("Ammo")
            local storedAmmoValue = weapon:FindFirstChild("StoredAmmo")
            if ammoValue and ammoValue:IsA("IntValue") then
                DefaultAmmoValues[weapon.Name] = ammoValue.Value
            end
            if storedAmmoValue and storedAmmoValue:IsA("IntValue") then
                DefaultStoredAmmoValues[weapon.Name] = storedAmmoValue.Value
            end
        end
    end
else
    warn("Weapons folder not found in ReplicatedStorage!")
end

AmmoSection:Toggle("Enable Infinite Ammo", function(state)
    InfiniteAmmoEnabled = state

    if state then
        print("🔫 Infinite Ammo Enabled")
        if weaponsFolder then
            for _, weapon in ipairs(weaponsFolder:GetChildren()) do
                if weapon:IsA("Folder") then
                    local ammoValue = weapon:FindFirstChild("Ammo")
                    local storedAmmoValue = weapon:FindFirstChild("StoredAmmo")

                    -- Set both to high safe values
                    if ammoValue and ammoValue:IsA("IntValue") then
                        ammoValue.Value = 500
                    end
                    if storedAmmoValue and storedAmmoValue:IsA("IntValue") then
                        storedAmmoValue.Value = 300 -- 
                    end
                end
            end
        end
    else
        print("🔁 Infinite Ammo Disabled — restoring defaults")
        if weaponsFolder then
            for _, weapon in ipairs(weaponsFolder:GetChildren()) do
                if weapon:IsA("Folder") then
                    local ammoValue = weapon:FindFirstChild("Ammo")
                    local storedAmmoValue = weapon:FindFirstChild("StoredAmmo")

                    if ammoValue and ammoValue:IsA("IntValue") and DefaultAmmoValues[weapon.Name] then
                        ammoValue.Value = DefaultAmmoValues[weapon.Name]
                    end
                    if storedAmmoValue and storedAmmoValue:IsA("IntValue") and DefaultStoredAmmoValues[weapon.Name] then
                        storedAmmoValue.Value = DefaultStoredAmmoValues[weapon.Name]
                    end
                end
            end
        end
    end
end)

-----------------------------------------------------
-- Instant Reload Section (Weapons Tab)
-----------------------------------------------------
local ReloadSection = Weaponstab:Section("Instant Reload")

local InstantReloadEnabled = false
local DefaultReloadTimes = {}

local weaponsFolder = game:GetService("ReplicatedStorage"):FindFirstChild("Weapons")

-- Store default reload times
if weaponsFolder then
	for _, weapon in ipairs(weaponsFolder:GetChildren()) do
		if weapon:IsA("Folder") then
			local reloadValue = weapon:FindFirstChild("ReloadTime")
			if reloadValue and reloadValue:IsA("NumberValue") then
				DefaultReloadTimes[weapon.Name] = reloadValue.Value
			end
		end
	end
else
	warn("Weapons folder not found in ReplicatedStorage!")
end

ReloadSection:Toggle("Enable Instant Reload", function(state)
	InstantReloadEnabled = state

	if state then
		print("⚡ Instant Reload Enabled")
		for _, weapon in ipairs(weaponsFolder:GetChildren()) do
			if weapon:IsA("Folder") then
				local reloadValue = weapon:FindFirstChild("ReloadTime")
				if reloadValue and reloadValue:IsA("NumberValue") then
					reloadValue.Value = 0
				end
			end
		end
	else
		print("🔁 Instant Reload Disabled — restoring defaults")
		for _, weapon in ipairs(weaponsFolder:GetChildren()) do
			if weapon:IsA("Folder") then
				local reloadValue = weapon:FindFirstChild("ReloadTime")
				if reloadValue and reloadValue:IsA("NumberValue") and DefaultReloadTimes[weapon.Name] then
					reloadValue.Value = DefaultReloadTimes[weapon.Name]
				end
			end
		end
	end
end)
